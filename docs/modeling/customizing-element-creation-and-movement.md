---
title: 要素作成処理および要素移動処理のカスタマイズ
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- vs.dsltools.dsldesigner.elementmergedirective
helpviewer_keywords:
- Domain-Specific Language, element merge directives
author: jillre
ms.author: jillfra
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 192bde210d7188e54576453dc04654e970df27f4
ms.sourcegitcommit: 5f6ad1cefbcd3d531ce587ad30e684684f4c4d44
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/22/2019
ms.locfileid: "72747614"
---
# <a name="customizing-element-creation-and-movement"></a>要素作成処理および要素移動処理のカスタマイズ

ツールボックスから、または貼り付け操作または移動操作で、要素を別の要素にドラッグすることを許可できます。 指定したリレーションシップを使用して、移動された要素をターゲット要素にリンクすることができます。

要素マージディレクティブ (EMD) は、1つのモデル要素が別のモデル要素に*マージ*された場合の動作を指定します。 これは、次の場合に発生します。

- ユーザーは、ツールボックスから図または図形にドラッグします。

- ユーザーは、エクスプローラーまたはコンパートメントシェイプの [追加] メニューを使用して要素を作成します。

- ユーザーは、あるスイムレーンから別のスイムレーンに項目を移動します。

- ユーザーが要素を貼り付けます。

- プログラムコードは、要素マージディレクティブを呼び出します。

作成操作はコピー操作とは異なるように見えるかもしれませんが、実際には同じように動作します。 たとえば、ツールボックスから要素が追加されると、そのプロトタイプのプロトタイプがレプリケートされます。 プロトタイプは、モデルの別の部分からコピーされた要素と同じ方法でモデルにマージされます。

EMD の役割は、オブジェクトまたはオブジェクトのグループをモデル内の特定の場所にマージする方法を決定することです。 具体的には、マージされたグループをモデルにリンクするためにインスタンス化する必要があるリレーションシップを決定します。 また、プロパティを設定したり、追加のオブジェクトを作成したりするようにカスタマイズすることもできます。

![DSL&#45;EMD&#95;Merge](../modeling/media/dsl-emd_merge.png)

埋め込みリレーションシップを定義すると、EMD が自動的に生成されます。 この既定の EMD は、ユーザーが新しい子インスタンスを親に追加するときに、リレーションシップのインスタンスを作成します。 たとえば、カスタムコードを追加するなどして、これらの既定値を変更できます。

DSL 定義に独自の内容を追加することもできます。これにより、マージされたクラスと受信するクラスのさまざまな組み合わせをユーザーがドラッグまたは貼り付けられるようになります。

## <a name="defining-an-element-merge-directive"></a>要素マージディレクティブの定義

要素マージディレクティブは、ドメインクラス、ドメインリレーションシップ、図形、コネクタ、および図に追加できます。 受信側ドメインクラスの下の DSL エクスプローラーで、追加または検索できます。 受信側のクラスは、モデル内に既に存在する要素のドメインクラスで、新しい要素またはコピーされる要素がマージされます。

![DSL&#45;EMD&#95;の詳細](../modeling/media/dsl-emd_details.png)

**Indexing クラス**は、受信側クラスのメンバーにマージできる要素のドメインクラスです。 **[サブクラスに適用]** を False に設定しない限り、インデックス作成クラスのサブクラスのインスタンスもこの EMD によってマージされます。

Merge ディレクティブには、次の2種類があります。

- **Process Merge**ディレクティブは、新しい要素がツリーにリンクされるリレーションシップを指定します。

- **前方マージ**ディレクティブは、新しい要素を別の受信要素 (通常は親) にリダイレクトします。

マージディレクティブには、カスタムコードを追加できます。

- Set**では、カスタムの accept を使用**して独自のコードを追加し、インデックスを作成する要素の特定のインスタンスをターゲット要素にマージするかどうかを決定します。 ユーザーがツールボックスからドラッグすると、"無効" のポインターは、コードがマージを許可しないかどうかを示します。

   たとえば、受信側の要素が特定の状態にある場合にのみ、マージを許可できます。

- Set**はカスタムマージを使用**して独自のコードを追加し、マージの実行時にモデルに加えられた変更を定義します。

   たとえば、モデル内の新しい場所からのデータを使用して、マージされた要素のプロパティを設定できます。

> [!NOTE]
> カスタムマージコードを記述する場合は、この EMD を使用して実行されたマージのみが影響を受けます。 同じ型のオブジェクトをマージする他の入力がある場合、または EMD を使用せずにこれらのオブジェクトを作成する他のカスタムコードがある場合は、カスタムマージコードによる影響を受けません。
>
> 新しい要素または新しいリレーションシップが必ずカスタムコードによって処理されるようにするには、埋め込みリレーションシップでの `AddRule` と、要素のドメインクラスの `DeleteRule` を定義することを検討してください。 詳細については、「[ルールによってモデル内の変更が反映される](../modeling/rules-propagate-changes-within-the-model.md)」を参照してください。

## <a name="example-defining-an-emd-without-custom-code"></a>例: カスタムコードを使用せずに EMD を定義する

次の例では、ユーザーが [ツールボックス] から既存の図形にドラッグして、要素とコネクタを同時に作成できます。 この例では、DSL 定義に EMD を追加します。 この変更を行う前に、ユーザーはツールを図にドラッグできますが、既存の図形にはドラッグできません。

ユーザーは、要素を他の要素に貼り付けることもできます。

### <a name="to-let-users-create-an-element-and-a-connector-at-the-same-time"></a>ユーザーが要素とコネクタを同時に作成できるようにするには

1. **最小言語**ソリューションテンプレートを使用して、新しい DSL を作成します。

    この DSL を実行すると、図形と図形の間に図形とコネクタを作成できるようになります。 新しい例の**要素**図形をツールボックスから既存の図形にドラッグすることはできません。

2. ユーザーが要素を `ExampleElement` 図形にマージできるようにするには、`ExampleElement` ドメインクラスに新しい EMD を作成します。

   1. **DSL エクスプローラー**で、 **[ドメインクラス]** を展開します。 @No__t_0 を右クリックし、 **[新しい要素のマージディレクティブの追加]** をクリックします。

   2. 新しい EMD の詳細を確認できるように、 **DSL の詳細**ウィンドウが開いていることを確認します。 (メニュー:**表示**、**その他のウィンドウ**、 **DSL の詳細**。)

3. DSL の詳細ウィンドウで**インデックス作成クラス**を設定して、`ExampleElement` オブジェクトにマージできる要素のクラスを定義します。

    この例では、[`ExampleElements`] を選択して、ユーザーが新しい要素を既存の要素にドラッグできるようにします。

    インデックス作成クラスが DSL エクスプローラーの EMD の名前になることに注意してください。

4. **[リンクを作成してマージを処理する]** で、次の2つのパスを追加します。

   - 1つのパスによって、新しい要素が親モデルにリンクされます。 入力する必要があるパス式は、親モデルとの埋め込みリレーションシップを通じて、既存の要素から移動します。 最後に、新しい要素が割り当てられる新しいリンク内のロールを指定します。 パスは次のとおりです。

      `ExampleModelHasElements.ExampleModel/!ExampleModel/.Elements`

   - もう1つのパスは、新しい要素を既存の要素にリンクします。 パス式では、参照リレーションシップと、新しい要素が割り当てられるロールを指定します。 このパスは次のとおりです。

      `ExampleElementReferencesTargets.Sources`

      パスナビゲーションツールを使用して、各パスを作成できます。

      1. **[パスにリンクを作成してマージを処理する]** で、[ **\<add パス >** ] をクリックします。

      2. リスト項目の右側にあるドロップダウン矢印をクリックします。 ツリービューが表示されます。

      3. ツリー内のノードを展開して、指定するパスを形成します。

5. DSL をテストします。

   1. **F5**キーを押して、ソリューションをリビルドして実行します。

        生成されたコードは新しい DSL 定義に準拠するようにテキストテンプレートから更新されるため、再構築には通常よりも長い時間がかかります。

   2. Visual Studio の実験用インスタンスが起動したら、DSL のモデルファイルを開きます。 いくつかの例の要素を作成します。

   3. [要素の**例**] ツールから既存の図形にドラッグします。

        新しい図形が表示され、コネクタを使用して既存の図形にリンクされます。

   4. 既存の図形をコピーします。 別の図形を選択して貼り付けます。

        最初の図形のコピーが作成されます。  新しい名前が付けられ、コネクタを使用して2番目の図形にリンクされます。

この手順では、次の点に注意してください。

- 要素マージディレクティブを作成することにより、要素の任意のクラスが他の要素を受け入れることができるようになります。 EMD が受信側ドメインクラスに作成され、承認されたドメインクラスが**Index class**フィールドに指定されます。

- パスを定義することで、新しい要素を既存のモデルに接続するために使用するリンクを指定できます。

     指定するリンクには、埋め込みリレーションシップが1つ含まれている必要があります。

- EMD は、ツールボックスからの作成と貼り付け操作の両方に影響します。

     新しい要素を作成するカスタムコードを記述する場合は、`ElementOperations.Merge` メソッドを使用して明示的に EMD を呼び出すことができます。 これにより、コードは、他の操作と同じ方法で新しい要素をモデルにリンクします。 詳細については、「[コピー動作のカスタマイズ](../modeling/customizing-copy-behavior.md)」を参照してください。

## <a name="example-adding-custom-accept-code-to-an-emd"></a>例: カスタム Accept コードを EMD に追加する

カスタムコードを EMD に追加することで、より複雑なマージ動作を定義できます。 この単純な例では、ユーザーが一定数以上の要素を図に追加できないようにしています。 この例では、埋め込みリレーションシップに付随する既定の EMD を変更します。

### <a name="to-write-custom-accept-code-to-restrict-what-the-user-can-add"></a>ユーザーが追加できる内容を制限するカスタム受け入れコードを記述するには

1. **最小言語**ソリューションテンプレートを使用して DSL を作成する。 DSL 定義図を開きます。

2. DSL エクスプローラーで、**ドメインクラス**、`ExampleModel`、**要素マージディレクティブ** の順に展開します。 @No__t_0 という名前の要素マージディレクティブを選択します。

     この EMD は、ユーザーが [ツールボックス] からドラッグして、モデル内の新しい `ExampleElement` オブジェクトを作成する方法を制御します。

3. DSL の**詳細**ウィンドウで、[**カスタムの受け入れを使用**する] を選択します。

4. ソリューションをリビルドします。 生成されたコードはモデルから更新されるため、この処理には通常より長い時間がかかります。

     次のようなビルドエラーが報告されます。 "ElementMergeSample 要素には、Canmerge 要素の定義が含まれていません..."

     メソッド `CanMergeExampleElement` を実装する必要があります。

5. **Dsl**プロジェクトに新しいコードファイルを作成します。 その内容を次のコードに置き換えて、名前空間をプロジェクトの名前空間に変更します。

    ```csharp
    using Microsoft.VisualStudio.Modeling;

    namespace Company.ElementMergeSample // EDIT.
    {
      partial class ExampleModel
      {
        /// <summary>
        /// Called whenever an ExampleElement is to be merged into this ExampleModel.
        /// This happens when the user pastes an ExampleElement
        /// or drags from the toolbox.
        /// Determines whether the merge is allowed.
        /// </summary>
        /// <param name="rootElement">The root element in the merging EGP.</param>
        /// <param name="elementGroupPrototype">The EGP that the user wants to merge.</param>
        /// <returns>True if the merge is allowed</returns>
        private bool CanMergeExampleElement(ProtoElementBase rootElement, ElementGroupPrototype elementGroupPrototype)
        {
          // Allow no more than 4 elements to be added:
          return this.Elements.Count < 4;
        }
      }
    }
    ```

    この単純な例では、親モデルにマージできる要素の数を制限しています。 より興味深い条件では、メソッドは、受信側オブジェクトのすべてのプロパティとリンクを検査できます。 また、<xref:Microsoft.VisualStudio.Modeling.ElementGroupPrototype> に格納されているマージ要素のプロパティを検査することもできます。 @No__t_0 の詳細については、「[コピー動作のカスタマイズ](../modeling/customizing-copy-behavior.md)」を参照してください。 モデルを読み取るコードを記述する方法の詳細については、「[プログラムコードでのモデルのナビゲーションと更新](../modeling/navigating-and-updating-a-model-in-program-code.md)」を参照してください。

6. DSL をテストします。

    1. **F5**キーを押してソリューションをリビルドします。 Visual Studio の実験用インスタンスが開いたら、DSL のインスタンスを開きます。

    2. 新しい要素をいくつかの方法で作成します。

        - [要素の**例**] ツールから図にドラッグします。

        - **モデルエクスプローラーの例**で、ルートノードを右クリックし、 **[新しいサンプル要素の追加]** をクリックします。

        - 図に要素をコピーして貼り付けます。

    3. これらの方法のいずれかを使用して、モデルに4つ以上の要素を追加できないことを確認します。 これは、すべてが要素マージディレクティブを使用するためです。

## <a name="example-adding-custom-merge-code-to-an-emd"></a>例: カスタムマージコードを EMD に追加する

カスタムマージコードでは、ユーザーがツールをドラッグしたとき、または要素に貼り付けたときの動作を定義できます。 カスタムマージを定義するには、次の2つの方法があります。

1. Set**はカスタムマージを使用**し、必要なコードを提供します。 生成されたマージコードはコードに置き換えられます。 このオプションは、マージの対象を完全に再定義する場合に使用します。

2. @No__t_0 メソッドをオーバーライドし、必要に応じて `MergeDisconnect` メソッドをオーバーライドします。 これを行うには、ドメインクラスの [ **Double の派生**プロパティを生成する] を設定する必要があります。 コードでは、基底クラスで生成されたマージコードを呼び出すことができます。 マージの実行後に追加の操作を実行する場合は、このオプションを使用します。

   これらの方法は、この EMD を使用して実行されるマージにのみ影響します。 マージされた要素を作成するすべての方法に影響を与える場合は、埋め込みリレーションシップの `AddRule` とマージされたドメインクラスの `DeleteRule` を定義する方法があります。 詳細については、「[ルールによってモデル内の変更が反映される](../modeling/rules-propagate-changes-within-the-model.md)」を参照してください。

### <a name="to-override-mergerelate"></a>MergeRelate をオーバーライドするには

1. DSL 定義で、コードを追加する EMD を定義していることを確認します。 必要に応じて、前のセクションで説明したように、パスを追加し、カスタムの accept コードを定義できます。

2. DslDefinition ダイアグラムで、マージの受信クラスを選択します。 通常は、埋め込みリレーションシップのソースエンドのクラスです。

     たとえば、最小言語ソリューションから生成された DSL では、[`ExampleModel`] を選択します。

3. **[プロパティ]** ウィンドウで、[ **Double の派生**を**true**に生成] を設定します。

4. ソリューションをリビルドします。

5. **DslFiles\DomainClasses.cs**の内容を検査します。 @No__t_0 という名前のメソッドを検索し、その内容を確認します。 これは、独自のバージョンを記述するのに役立ちます。

6. 新しいコードファイルで、受信側クラスの部分クラスを記述し、`MergeRelate` メソッドをオーバーライドします。 基本メソッドを必ず呼び出してください。 (例:

    ```csharp
    partial class ExampleModel
    {
      /// <summary>
      /// Called when the user drags or pastes an ExampleElement onto the diagram.
      /// Sets the time of day as the name.
      /// </summary>
      /// <param name="sourceElement">Element to be added</param>
      /// <param name="elementGroup">Elements to be merged</param>
      protected override void MergeRelate(ModelElement sourceElement, ElementGroup elementGroup)
      {
        // Connect the element according to the EMD:
        base.MergeRelate(sourceElement, elementGroup);

        // Custom actions:
        ExampleElement mergingElement = sourceElement as ExampleElement;
        if (mergingElement != null)
        {
          mergingElement.Name = DateTime.Now.ToLongTimeString();
        }
      }
    }
    ```

### <a name="to-write-custom-merge-code"></a>カスタムマージコードを記述するには

1. **生成された codedomaincs**で、`MergeRelate` という名前のメソッドを検査します。 これらのメソッドは、新しい要素と既存のモデル間のリンクを作成します。

    また、`MergeDisconnect` という名前のメソッドを検査します。 これらのメソッドは、要素を削除するときに、その要素をモデルからリンク解除します。

2. **DSL エクスプローラー**で、カスタマイズする要素マージディレクティブを選択または作成します。 DSL の**詳細**ウィンドウで、[**カスタムマージを使用**する] を設定します。

    このオプションを設定した場合、 **merge**オプションと**Forward merge**オプションは無視されます。 代わりに、コードが使用されます。

3. ソリューションをリビルドします。 生成されたコードファイルがモデルから更新されるため、通常よりも時間がかかります。

    エラーメッセージが表示されます。 エラーメッセージをダブルクリックすると、生成されたコードの指示が表示されます。 ここでは、2つのメソッドを指定する方法を説明します。*domainclass*を `MergeRelate` し、*domainclass*を `MergeDisconnect` します。

4. 部分クラス定義内のメソッドを別のコードファイルに記述します。 前に検査した例では、必要なものを提案します。

   カスタムマージコードは、オブジェクトとリレーションシップを直接作成するコードには影響しません。また、他の変更には影響しません。 要素の作成方法に関係なく、追加の変更が実装されていることを確認するには、代わりに `AddRule` と `DeleteRule` を記述することを検討してください。 詳細については、「[ルールによってモデル内の変更が反映される](../modeling/rules-propagate-changes-within-the-model.md)」を参照してください。

## <a name="redirecting-a-merge-operation"></a>マージ操作のリダイレクト

前方マージディレクティブは、マージ操作の対象をリダイレクトします。 通常、新しいターゲットは、初期ターゲットの埋め込み親です。

たとえば、コンポーネント図テンプレートを使用して作成された DSL では、ポートはコンポーネントに埋め込まれます。 ポートは、コンポーネント図形の端に小さい図形として表示されます。 ユーザーは、ポートツールをコンポーネント図形にドラッグして、ポートを作成します。 ただし、ユーザーがポートツールをコンポーネントではなく既存のポートに誤ってドラッグすると、操作が失敗することがあります。 これは、既存のポートが複数存在する場合の簡単な間違いです。 この迷惑を回避するには、既存のポートにポートをドラッグできるようにしますが、アクションは親コンポーネントにリダイレクトされます。 操作は、ターゲット要素がコンポーネントであるかのように動作します。

事前マージディレクティブは、コンポーネントモデルソリューションで作成できます。 元のソリューションをコンパイルして実行すると、ユーザーが**ツールボックス**から任意の数の**入力ポート**または**出力ポート**要素を**コンポーネント**要素にドラッグできることがわかります。 ただし、既存のポートにポートをドラッグすることはできません。 使用できないポインターは、この移動が有効になっていないことを警告します。 ただし、事前マージディレクティブを作成して、既存の**入力ポート**で意図せず削除されたポートが**Component**要素に転送されるようにすることができます。

### <a name="to-create-a-forward-merge-directive"></a>前方マージディレクティブを作成するには

1. コンポーネントモデルテンプレートを使用して [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] ソリューションを作成します。

2. DslDefinition を開き、 **Dsl エクスプローラー**を表示します。

3. **DSL エクスプローラー**で、 **[ドメインクラス]** を展開します。

4. **Componentport**抽象ドメインクラスは、 **InPort**と**outport**の両方の基本クラスです。 **[Componentport]** を右クリックし、 **[Add New Element Merge ディレクティブ]** をクリックします。

    **[要素マージディレクティブ]** ノードの下に、新しい**要素マージディレクティブ**ノードが表示されます。

5. **[要素マージディレクティブ]** ノードを選択し、 **[DSL の詳細]** ウィンドウを開きます。

6. インデックスクラス ボックスの一覧で  **Componentport** を選択します。

7. **[別のドメインクラスにマージを転送する]** を選択します。

8. パスの選択 の一覧で、 **Componentport**、**ComponentHasPorts** の順に展開し、**コンポーネント** を選択します。

    新しいパスは次のようになります。

    **ComponentHasPorts/! コンポーネント**

9. ソリューションを保存し、 **[ソリューションエクスプローラー]** ツールバーの右端にあるボタンをクリックしてテンプレートを変換します。

10. ソリューションをビルドして実行します。 Visual Studio の新しいインスタンスが表示されます。

11. **ソリューションエクスプローラー**で、サンプルの mydsl を開きます。 ダイアグラムと**Componentlanguage ツールボックス**が表示されます。

12. **[ツールボックス]** から**入力ポート**を別の入力ポートにドラッグし**ます。** 次に、 **outputport**を**inputport**にドラッグしてから、別の**outputport**にドラッグします。

     使用できないポインターは表示されず、既存のものに新しい**入力ポート**をドロップできます。 新しい**入力ポート**を選択し、**コンポーネント**上の別のポイントにドラッグします。

## <a name="see-also"></a>関連項目

- [プログラム コードにおけるモデル内の移動およびモデルの更新](../modeling/navigating-and-updating-a-model-in-program-code.md)
- [ツールおよびツールボックスのカスタマイズ](../modeling/customizing-tools-and-the-toolbox.md)
- [回路図のサンプル DSL](https://code.msdn.microsoft.com/Visualization-Modeling-SDK-763778e8)