---
title: T4 テキストテンプレートを作成するためのガイドライン |Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
ms.assetid: 04dd3fc4-10e8-488a-bdea-4d615f50f063
caps.latest.revision: 11
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: d1e15a8c00a0614d020defd2df7b06665289a8b2
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/19/2019
ms.locfileid: "72666049"
---
# <a name="guidelines-for-writing-t4-text-templates"></a>T4 テキスト テンプレートの記述に関するガイドライン
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

これらの一般的なガイドラインは、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)] でプログラムコードまたはその他のアプリケーションリソースを生成する場合に役立ちます。 これらは固定規則ではありません。

## <a name="guidelines-for-design-time-t4-templates"></a>デザイン時 T4 テンプレートのガイドライン
 デザイン時 T4 テンプレートは、デザイン時に [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] プロジェクト内のコードを生成するテンプレートです。 詳細については、「 [T4 テキストテンプレートを使用したデザイン時のコード生成](../modeling/design-time-code-generation-by-using-t4-text-templates.md)」を参照してください。

 アプリケーションの変数の側面を生成します。
コード生成は、プロジェクト中に変更される可能性があるアプリケーションの側面や、アプリケーションの異なるバージョン間で変更される可能性がある場合に最も役立ちます。 生成するものをより簡単に判断できるように、これらの変数の特性をより不変な部分から分離します。 たとえば、アプリケーションが Web サイトを提供する場合は、標準のページ機能を提供する機能を、ナビゲーションパスを定義するロジックから別のページに分割します。

 1つ以上のソースモデルで変数の特性をエンコードします。
モデルは、生成されるコードの変数部分の特定の値を取得するために各テンプレートが読み取られるファイルまたはデータベースです。 モデルには、データベース、独自のデザインの XML ファイル、ダイアグラム、またはドメイン固有の言語を使用できます。 通常、1つのモデルを使用して、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)] プロジェクトに多数のファイルを生成します。 各ファイルは、個別のテンプレートから生成されます。

 1つのプロジェクトで複数のモデルを使用できます。 たとえば、Web ページ間のナビゲーション用にモデルを定義したり、ページのレイアウトに別のモデルを定義したりすることができます。

 実装ではなく、ユーザーのニーズとボキャブラリでモデルに専念します。
たとえば、Web サイトアプリケーションでは、モデルが Web ページやハイパーリンクを参照することが想定されます。

 理想的には、モデルが表す情報の種類に適したプレゼンテーション形式を選択します。 たとえば、Web サイトを介したナビゲーションパスのモデルは、ボックスと矢印の図になります。

 生成されたコードをテストします。
手動テストまたは自動テストを使用して、結果のコードがユーザーの必要に応じて動作することを確認します。 コードの生成元と同じモデルからテストを生成しないようにします。

 場合によっては、一般的なテストをモデルに対して直接実行できます。 たとえば、Web サイト内のすべてのページが、他のユーザーからのナビゲーションによって到達できることを確認するテストを作成できます。

 カスタムコードを許可する: 部分クラスを生成します。
生成されたコードに加えて、手動で記述したコードを許可します。 コード生成スキームで、発生する可能性があるすべてのバリエーションを考慮することは通常ありません。 したがって、生成されたコードの一部を追加またはオーバーライドすることをお勧めします。 生成されたマテリアルが [!INCLUDE[csprcs](../includes/csprcs-md.md)] や [!INCLUDE[vbprvb](../includes/vbprvb-md.md)] などの .NET 言語に含まれる場合は、次の2つの方法が特に便利です。

- 生成されたクラスは、部分的なものである必要があります。 これにより、生成されたコードにコンテンツを追加できます。

- クラスは、もう一方を継承するペアで生成される必要があります。 基底クラスには、生成されたメソッドとプロパティがすべて含まれている必要があり、派生クラスにはコンストラクターのみを含める必要があります。 これにより、記述されたコードで、生成されたメソッドをすべてオーバーライドできます。

  XML などの他の生成された言語では、`<#@include#>` ディレクティブを使用して、手動で記述したコンテンツと生成されたコンテンツを簡単に組み合わせて作成します。 より複雑なケースでは、生成されたファイルを任意のファイルに結合した後処理手順を記述しなければならない場合があります。

  共通素材をインクルードファイルまたは実行時テンプレートに移動して、複数のテンプレートで同様のテキストとコードブロックが繰り返されないようにするには、`<#@ include #>` ディレクティブを使用します。 詳細については、「 [T4 Include ディレクティブ](../modeling/t4-include-directive.md)」を参照してください。

  また、実行時のテキストテンプレートを別のプロジェクトにビルドし、デザイン時テンプレートから呼び出すこともできます。 これを行うには、`<#@ assembly #>` ディレクティブを使用して、別のプロジェクトにアクセスします。

  大きなコードブロックを別のアセンブリに移動することを検討してください。
  大きなコードブロックとクラスの機能ブロックがある場合は、別のプロジェクトでコンパイルするメソッドにこのコードの一部を移動すると便利な場合があります。 @No__t_0 ディレクティブを使用して、テンプレート内のコードにアクセスできます。 詳細については、「 [T4 アセンブリディレクティブ](../modeling/t4-assembly-directive.md)」を参照してください。

  テンプレートが継承できる抽象クラスにメソッドを配置できます。 抽象クラスは <xref:Microsoft.VisualStudio.TextTemplating.TextTransformation?displayProperty=fullName> から継承する必要があります。 詳細については、「 [T4 テンプレートディレクティブ](../modeling/t4-template-directive.md)」を参照してください。

  コードを生成します。構成ファイルではありません。変数アプリケーションを記述する方法の1つは、構成ファイルを受け入れる汎用プログラムコードを記述することです。 このように記述されたアプリケーションは非常に柔軟であり、ビジネス要件が変更されたときに、アプリケーションを再構築せずに再構成することができます。 ただし、この方法の欠点は、アプリケーションがより具体的なアプリケーションよりも動作が少なくなることです。 また、プログラムコードは、ほとんどのジェネリック型を常に処理することになるため、読み取りと保守がより困難になります。

  これに対して、コンパイル前に変数部分が生成されるアプリケーションは、厳密に型指定できます。 これにより、手作業で記述されたコードをより簡単かつ確実に記述し、ソフトウェアの生成された部分と統合できます。

  コード生成の利点を最大限に活用するには、構成ファイルではなくプログラムコードを生成してみてください。

  生成されたコードフォルダーを使用して、生成された**コード**という名前のプロジェクトフォルダーにテンプレートおよび生成されたファイルを配置し、これらが直接編集する必要のあるファイルではないことを明確にします。 生成されたクラスをオーバーライドまたは追加するカスタムコードを作成する場合は、それらのクラスを**カスタムコード**という名前のフォルダーに配置します。 一般的なプロジェクトの構造は次のようになります。

```
MyProject
   Custom Code
      Class1.cs
      Class2.cs
   Generated Code
      Class1.tt
          Class1.cs
      Class2.tt
          Class2.cs
   AnotherClass.cs

```

## <a name="guidelines-for-run-time-preprocessed-t4-templates"></a>実行時 (前処理済み) の T4 テンプレートのガイドライン
 共通素材を継承されたテンプレートに移動する継承を使用して、T4 テキストテンプレート間でメソッドとテキストブロックを共有できます。 詳細については、「 [T4 テンプレートディレクティブ](../modeling/t4-template-directive.md)」を参照してください。

 また、実行時テンプレートを含むインクルードファイルを使用することもできます。

 大規模なコード本体を部分クラスに移動します。
各ランタイムテンプレートでは、テンプレートと同じ名前を持つ部分クラス定義が生成されます。 同じクラスの別の部分定義を含むコードファイルを作成できます。 この方法では、メソッド、フィールド、およびコンストラクターをクラスに追加できます。 これらのメンバーは、テンプレートのコードブロックから呼び出すことができます。

 これを行う利点は、IntelliSense を使用できるため、コードの記述が簡単になることです。 また、プレゼンテーションと基になるロジックをより適切に分離することもできます。

 たとえば、 **MyReportText.tt**の場合は次のようになります。

 `The total is: <#= ComputeTotal() #>`

 **MyReportText-Methods.cs**の場合:

 `private string ComputeTotal() { ... }`

 カスタムコードを許可する: 拡張ポイントを指定する \< # + クラス機能ブロック # > で仮想メソッドを生成することを検討してください。 これにより、1つのテンプレートを変更せずに多くのコンテキストで使用できます。 テンプレートを変更する代わりに、追加のロジックを最小限にする派生クラスを作成できます。 派生クラスは、通常のコードでも、実行時テンプレートでもかまいません。

 たとえば、MyStandardRunTimeTemplate.tt の場合は次のようになります。

```
This page is copyright <#= CompanyName() #>.
<#+ protected virtual string CompanyName() { return ""; } #>
```

 アプリケーションのコードを次に示します。

```
class FabrikamTemplate : MyStandardRunTimeTemplate
{
  protected override string CompanyName() { return "Fabrikam"; }
}
...
  string PageToDisplay = new FabrikamTemplate().TextTransform();

```

## <a name="guidelines-for-all-t4-templates"></a>すべての T4 テンプレートのガイドライン
 データをテキスト生成から個別に収集するには、計算とテキストブロックの混合を避けるようにしてください。 各テキストテンプレートでは、最初の \< # code ブロック # > を使用して変数を設定し、複雑な計算を実行します。 最初のテキストブロックからテンプレートの末尾まで、または最初の \< # + クラス機能ブロック # > では、長い式を避け、テキストブロックが含まれている場合を除き、ループと条件を回避します。 これにより、テンプレートが読みやすくなり、保守も容易になります。

 インクルードファイルに `.tt` を使用しないでください。インクルードファイルには、`.ttinclude` などの別のファイル名拡張子を使用します。 @No__t_0 は、実行時またはデザイン時のテキストテンプレートとして処理するファイルに対してのみ使用します。 場合によっては、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)] が `.tt` ファイルを認識し、それらのプロパティが自動的に処理されるように設定します。

 各テンプレートを固定プロトタイプとして起動します。
生成するコードまたはテキストの例を記述し、それが正しいことを確認します。 次に、拡張機能を .tt に変更し、モデルを読み取ってコンテンツを変更するコードをインクリメンタルに挿入します。

 型指定されたモデルの使用を検討してください。
モデルの XML スキーマまたはデータベーススキーマを作成することもできますが、ドメイン固有言語 (DSL) を作成すると便利な場合があります。 DSL には、スキーマ内の各ノードを表すクラスと、属性を表すプロパティが生成されるという利点があります。 これは、ビジネスモデルの観点からプログラミングできることを意味します。 (例:

```
Team Members:
<# foreach (Person p in team.Members)
 { #>
    <#= p.Name #>
<# } #>
```

 モデルに図を使用することを検討してください。
多くのモデルは、特にサイズが非常に大きい場合に、単純にテキストテーブルとして提示および管理されます。

 ただし、ビジネス要件によっては、複雑なリレーションシップセットとワークフローを明確にすることが重要です。また、図は最適なメディアです。 図の利点は、ユーザーや他の利害関係者と簡単に議論できることです。 ビジネス要件のレベルでモデルからコードを生成することにより、要件が変化したときにコードの柔軟性を高めることができます。

 多くの場合、UML クラスとアクティビティ図は、これらの目的に合わせて調整できます。 また、独自の種類の図をドメイン固有言語 (DSL) として設計することもできます。 コードは、UML と Dsl の両方から生成できます。 詳細については、「[アーキテクチャの分析とモデリング](../modeling/analyze-and-model-your-architecture.md)」と「[アーキテクチャの分析とモデリング](../modeling/analyze-and-model-your-architecture.md)」を参照してください。

## <a name="see-also"></a>参照
 T4 テキストテンプレートを[使用したデザイン時のコード生成](../modeling/design-time-code-generation-by-using-t4-text-templates.md)T4 テキストテンプレートを使用し[た実行時テキスト生成](../modeling/run-time-text-generation-with-t4-text-templates.md)
