---
title: 使用法に関する警告
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- warnings, usage
- managed code analysis warnings, usage warnings
- usage warnings
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: e607da01d160212eea03b1fe81dfb2fbf4ede3f6
ms.sourcegitcommit: 034c503ae04e22cf840ccb9770bffd012e40fb2d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/14/2019
ms.locfileid: "72305691"
---
# <a name="usage-warnings"></a>使用法に関する警告

使用状況の警告は、.NET の適切な使用をサポートします。

## <a name="in-this-section"></a>このセクションの内容

|Rule|説明|
|----------|-----------------|
|[CA1801:未使用のパラメーターを確認する @ no__t-0|メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。|
|[CA1806:メソッドの結果を無視しない @ no__t-0|新しく作成されたオブジェクトが現在まで使用されていないか、新しい文字列を作成して返すメソッドが呼び出されて作成された新しい文字列が現在まで使用されていません。あるいは、COM または P/Invoke メソッドから返された HRESULT またはエラー コードが現在まで使用されていません。|
|[CA1816:GC を呼び出します。Gc.suppressfinalize @ no__t-0|Dispose の実装であるメソッドでは、GC は呼び出されません。SuppressFinalize;または、Dispose の実装ではないメソッドは、GC を呼び出します。SuppressFinalize;または、GC のメソッド呼び出し。SuppressFinalize およびこの (Visual Basic で Me) 以外は何かのパス。|
|[CA2200:スタックの詳細を保持するための再スロー @ no__t-0|例外が再スローされ、その例外が throw ステートメントで明示的に指定されています。 throw ステートメントで例外を指定して例外が再スローされると、例外をスローした元のメソッドと現在のメソッドの間で呼び出されたメソッドの一覧は失われます。|
|[CA2201:予約された例外の種類を発生させない @ no__t-0|これにより、元のエラーの検出とデバッグが困難になります。|
|[CA2202:オブジェクトを複数回破棄することはできません @ no__t-0|メソッドの実装に、同じオブジェクトに対して System.IDisposable.Dispose または Dispose と同等の操作 (たとえば、一部の型に対する Close() メソッドなど) を複数回呼び出すコード パスが含まれています。|
|[CA2204:リテラルのスペルは正しい @ no__t-0|メソッド本体に含まれるリテラル文字列内に Microsoft スペル チェック ライブラリで認識されない語が 1 つ以上あります。|
|[CA2205:Win32 API @ no__t のマネージドに相当するものを使用する-0|プラットフォーム呼び出しメソッドが定義されており、同等の機能を持つ .NET メソッドを使用できます。|
|[CA2207:値型の静的フィールドの初期化 @ no__t-0|値型で明示的な静的コンストラクターを宣言しています。 この規則違反を修正するには、静的データが宣言されたとき、および静的コンストラクターを削除するときに、静的データをすべて初期化します。|
|[CA2208:引数の例外を正しくインスタンス化する @ no__t-0|ArgumentException またはそのクラスから派生した例外の種類の既定 (パラメーターなし) のコンストラクターに対して呼び出しが行われたか、ArgumentException またはそのクラスから派生した例外の種類のパラメーター付きのコンストラクターに不適切な文字列型の引数が渡されました。|
|[CA2211:非定数フィールドは表示されません @ no__t-0|定数または読み取り専用ではない静的フィールドは、スレッドセーフではありません。 このようなフィールドへのアクセスは慎重に制御する必要があり、クラスオブジェクトへのアクセスを同期するための高度なプログラミング手法が必要です。|
|[CA2212:サービスコンポーネントを WebMethod @ no__t でマークしない|System.enterpriseservices を継承する型のメソッドは、WebMethodAttribute でマークされています。 ServicedComponent WebMethodAttribute と ServicedComponent メソッドは、コンテキストおよびトランザクション フローの動作および要件が衝突するため、状況によっては正常に動作しません。|
|[CA2213: 破棄可能なフィールドは破棄されなければなりません](../code-quality/ca2213-disposable-fields-should-be-disposed.md)|System.IDisposable を実装する型が、IDisposable も実装する型を持つフィールドを宣言しています。 このフィールドの Dispose メソッドは、宣言する型の Dispose メソッドから呼び出されていません。|
|[CA2214:コンストラクター @ no__t のオーバーライド可能なメソッドを呼び出さないでください。|コンストラクターが仮想メソッドを呼び出すと、そのメソッドを呼び出すインスタンスのコンストラクターが実行されていない可能性があります。|
|[CA2215:Dispose メソッドは基底クラスの dispose @ no__t を呼び出す必要があります。|型が、破棄できる型から継承している場合、使用している Dispose メソッド内から基本型の Dispose メソッドを呼び出す必要があります。|
|[CA2216:破棄可能な型はファイナライザー @ no__t を宣言しなければなりません|System.object を実装し、アンマネージリソースの使用を提案するフィールドを持つ型は、「オブジェクトの最終処理」で説明されているように、ファイナライザーを実装しません。|
|[CA2217:FlagsAttribute @ no__t で列挙をマークしません。|外部から参照できる列挙体は、FlagsAttribute でマークされ、列挙体の2つまたは複数の定義済みの値の組み合わせではない1つ以上の値を持ちます。|
|[CA2218:オーバーライドする Equals で GetHashCode をオーバーライドする @ no__t-0|GetHashCode は、現在のインスタンスに基づいて、ハッシュ アルゴリズムとデータ構造 (ハッシュ テーブルなど) に適した値を返します。 同じ型で等値の 2 つのオブジェクトによって同じハッシュ コードが返される必要があります。|
|[CA2219:例外句で例外を発生させない @ no__t-0|finally 句または fault 句で例外が発生すると、アクティブな例外が新しい例外によって隠されます。 filter 句で例外が発生すると、ランタイムがその例外を暗黙的にキャッチします。 これにより、元のエラーの検出とデバッグが困難になります。|
|[CA2220:ファイナライザーは基底クラスのファイナライザー @ no__t を呼び出す必要があります。|終了処理は、継承の階層構造を使用して反映する必要があります。 これを確実に行うには、型が型の Finalize メソッドで基本クラスの Finalize メソッドを呼び出す必要があります。|
|[CA2221:ファイナライザーを保護する必要があります @ no__t-0|ファイナライザーは、ファミリ アクセス修飾子を使用する必要があります。|
|[CA2222:継承されたメンバーの可視性を下げる @ no__t-0|継承されたメンバーのアクセス修飾子は変更しないでください。 継承メンバーをプライベートに変更しても、呼び出し元はメソッドの基本クラスの実装にアクセスできます。|
|[CA2223:メンバーは、戻り値の型が異なる場合 @ no__t-0|共通言語ランタイムでは、戻り値の型以外は同じであるメンバーの区別に戻り値の型を使用することが許可されていますが、この機能は共通言語仕様ではなく、.NET プログラミング言語の共通機能でもありません。|
|[CA2224:オーバーロード演算子に equals をオーバーライドします。 @ no__t-0|パブリック型は等値演算子を実装しますが、Object.equals をオーバーライドしません。|
|[CA2225:演算子のオーバーロードには代替名 @ no__t があります。|演算子のオーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。 名前付き代替メンバーは、演算子と同じ機能へのアクセスを提供し、オーバーロードされた演算子をサポートしない言語でプログラミングする開発者向けに用意されています。|
|[CA2226:演算子には、対称的なオーバーロード @ no__t-0 が必要です。|型は等値演算子または非等値演算子を実装し、逆の演算子は実装しません。|
|[CA2227:コレクションのプロパティは読み取り専用でなければなりません @ no__t-0|書き込み可能なコレクション プロパティにより、ユーザーはコレクションを異なるコレクションで置換できます。 読み取り専用プロパティは、コレクションを置換できないようにしますが、個別のメンバーが設定されることは回避できません。|
|[CA2228:未リリースのリソース形式 @ no__t を出荷しないでください。|プレリリース版の .NET を使用してビルドされたリソースファイルは、サポートされているバージョンの .NET では使用できない可能性があります。|
|[CA2229: シリアル化コンストラクターを実装します](../code-quality/ca2229-implement-serialization-constructors.md)|この規則違反を修正するには、シリアル化コンストラクターを実装します。 シールされたクラスの場合、コンストラクターをプライベートにするか、プロテクトにします。|
|[CA2230:変数引数に params を使用する @ no__t-0|パブリック型またはプロテクト型に、params キーワードではなく VarArgs 呼び出し規則を使用するパブリック メソッドまたはプロテクト メソッドが含まれています。|
|[CA2231: ValueType.Equals のオーバーライドで、演算子 equals をオーバーロードします](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md)|値型は @no__t 0 よりも優先されますが、等値演算子は実装されません。|
|[CA2232:Windows フォームのエントリポイントを、キースレッド @ no__t を使用してマークします。|STAThreadAttribute は、アプリケーションの COM スレッド処理モデルがシングルスレッド アパートメントであることを示します。 この属性は、Windows フォームを使用するすべてのアプリケーションのエントリ ポイントに指定する必要があります。省略すると、Windows コンポーネントが正常に機能しないことがあります。|
|[CA2233:操作は、@ no__t をオーバーフローすることはできません。|最初にオペランドを検証せずに算術演算を実行しないでください。演算の結果が、関連するデータ型の有効な値の範囲を超えていないことを確認してください。|
|[CA2234:文字列の代わりに system.string オブジェクトを渡す @ no__t-0|"uri"、"URI"、"urn"、"URN"、"url"、または "URL" という名前を持つ文字列パラメーターが指定されているメソッドに対して、呼び出しが行われました。  そのメソッドの型宣言に対応するメソッドのオーバーロードが存在し、それに対して System.Uri パラメーターが指定されています。|
|[CA2235:すべてのシリアル化不可能なフィールドを設定します](../code-quality/ca2235-mark-all-non-serializable-fields.md)|シリアル化できない型のインスタンス フィールドが、シリアル化できる型で宣言されています。|
|[CA2236:ISerializable 型で基底クラスメソッドを呼び出す @ no__t-0|この規則違反を修正するには、基本型の GetObjectData メソッドまたはシリアル化コンストラクターを、対応する派生型のメソッドまたはコンストラクターから呼び出します。|
|[CA2237:ISerializable 型を SerializableAttribute @ no__t にマークします|共通言語ランタイムによってシリアル化可能として認識されるようにするには、型が ISerializable インターフェイスの実装によってカスタムシリアル化ルーチンを使用する場合でも、型は SerializableAttribute 属性でマークする必要があります。|
|[CA2238:シリアル化メソッドを正しく実装する @ no__t-0|シリアル化イベントを処理するメソッドに、適切なシグネチャ、戻り値の型、または参照範囲がありません。|
|[CA2239:省略可能なフィールドに逆シリアル化メソッドを指定する @ no__t-0|型には OptionalFieldAttribute 属性でマークされたフィールドがありますが、この型ではシリアル化解除のイベント処理メソッドが提供されていません。|
|[CA2240:ISerializable を正しく @ no__t に実装します|この規則違反を修正するには、GetObjectData メソッドを表示およびオーバーライド可能にし、すべてのインスタンスフィールドがシリアル化プロセスに含まれるか、または NonSerializedAttribute 属性で明示的にマークされていることを確認します。|
|[CA2241:書式設定メソッドに正しい引数を指定する @ no__t-0|System.string に渡される format 引数に、各オブジェクト引数に対応する書式指定項目が含まれていません。また、その逆も同様です。|
|[CA2242:NaN を正しくテストする @ no__t-0|この式が Single.Nan または Double.Nan に対して値をテストしています。 値をテストするには、Single.IsNan(Single) または Double.IsNan(Double) を使用します。|
|[CA2243:属性文字列リテラルは、正しく解析する必要があります @ no__t-0|属性の文字列リテラルパラメーターは、URL、GUID、またはバージョンに対して正しく解析されません。|